# Рядки та методи

> У якому ми пограємось з рядками, додамо кілька чисел, розберемось з методами та перевіримо кілька умов…

Якщо ви читаєте цю книгу, то мабуть маєте бажання програмувати на мові Ruby, і якщо ви схожі на мене – вам вже хочеться прочитати її. Що ж, не будемо витрачати час дарма. Я припускаю, що у вас вже є встановлена мова Ruby, якщо ж ні - для початку вам потрібно встановити її і повернутися сюди.

> **Важливо:** Якщо ви користуєтесь Ruby In Steel, впевніться, що ви завантажили рішення LittleBookOfRuby.sln for easy access to all the sample programs.

Тепер, починаємо програмувати. Відкрийте ваш текстовий редактор, створіть файл та запишіть в нього наступне:

**`helloworld.rb`**:

```ruby
puts "hello world"
```

Тепер запустіть вашу програму (у Ruby In Steel натисніть <kbd>CTRL-F5</kbd>). Якщо все правильно, Ruby має показати «hello world»:

> Якщо ви користуєтесь текстовим редактором, який не має інтерактивної консолі, ви маєте запустити програму з допомогою командного рядка. Щоб зробити це, відкрийте вікно командного рядка (введіть `CMD` у меню «Пуск» на Windows) та перейдіть у директорію, що містить вихідний код, а тоді введіть `ruby` та назву програми, ось так:
>
> ```bash
> $ ruby helloworld.rb
> ```


Це напевно має бути найкоротша “hello world”–програма в історії програмування, тому ми одразу переходимо до отримання інформації від користувача…

Очевидний наступний крок - ми повинні “отримати” рядок. Ви могли вже здогадатися, що в Ruby такий метод називається `.gets`.

> ## Об'єкти і методи
>
> Ruby - повністю об'єктно орієнтована мова програмування. Все: від цифри до рядка - вважається об'єктом. Кожен об'єкт має вбудовані методи, які можуть бути застосовані для виконання якихось операцій. Для того щоб застосувати метод, ви повинні поставити крапку після об'єкта і написати ім'я методу. Для прикладу, тут я використаю метод `.upcase`  щоб вивести рядок “hello world” у верхньому регістрі:
>
> **`uppercase.rb`**:
>
> ```ruby
> puts "hello world".upcase
> ```
>
> Деякі методи, такі як `puts` і `.gets`  доступні скрізь, і не потребують зв'язку з конкретним методом. Говорячи технічною мовою, ці методи забезпечуються модулем ядра Ruby і вони включені до кожного об'єкта в Ruby. Коли ви запускаєте Ruby додаток - автоматично створюється головний об'єкт, який надає доступ до методів Ядра.

Програма **`helloname.rb`** повинна запитати в користувача його ім'я, припустимо, що це “Fred” — тоді на моніторі повинно з'явитися привітання: “Hello Fred”. Ось її код:

**`helloname.rb`**:

```ruby
print 'Enter your name:'
name = gets
puts "Hello #{name}"
```

Це все виглядає дуже просто, але водночас потрібно детальніше розглянути деякі нюанси. По-перше, зверніть увагу, що я використав `print`, а не `puts` для запиту на введення імені. Це тому, що `puts` в кінці рядка ставить символ переносу на новий рядок, на відміну від `print`, який такого не робить. В даному випадку я хочу, щоб курсор залишався в тому ж рядку що і запит вводу тексту.

В наступному рядку я використовую `gets()` для зчитування введеної користувачем інформації, яке відбувається після натиснення клавіші Enter. Цей рядок призначений змінній `name`. Я попередньо не визначав цієї змінної і до того ж я не вказав її тип. В Ruby ви можете створювати змінні коли захочете і Ruby сама визначить їхній тип. Тут я присвоїв змінній `name` рядок і Ruby сама визначила, що тип змінної повинен бути string.

> **Зауважте:** Ruby чутлива до регістру. Тобто змінна `myvar` і `myVar` - дві різні змінні. Змінні, такі як `name`  у нашому прикладі - повинні починатися з малої літери.

Між іншим, дужки після `gets()` не є обов’язковими, як і дужки, що охоплюють рядки після `print` та `puts`: код запуститься так само, якщо ви видалите дужки. Дужки допомагають уникати двозначності в коді і, в деяких випадках, інтерпритатор попередить вас, якщо ви їх пропустите. Деякі Ruby розробники полюбляють пропускати дужки щоразу, коли це можливо - я не поділяю їхньої думки. Тому в цій книзі ви будете бачити приклади коду саме з дужками.

## Рядки та інтерполяція

Останній рядок файлу **`helloname.rb`** досить цікавий:

```ruby
puts("Hello #{name}")
```

Тут змінна `name` вбудовує себе в рядок. Це відбувається шляхом розміщення змінної між двома фігурними дужками, перед якими стоїть символ решітки `#{}`. Такий тип “підстановки” працює тільки в рядках з подвійними лапками.

В подвійних лапках ви можете не тільки вбудовувати змінні, а також маєте можливість вставити такі невидимі символи нового рядка `"\n"` та табів `"\t"`.

Ви навіть можете вставляти програмний код або математичні вирази. Уявімо, що у вас є метод `showname` який повертає рядок “Fred”. Наступний рядок буде містити інтерполяцію і викличе метод `showname` і, в результаті, буде відображатися рядок “Hello Fred”:

**`string_eval.rb`**:

```ruby
puts "Hello #{showname}"
```

Уважно подивіться і подумайте, що може вивести наступний рядок:

```ruby
puts "\n\t#{(1 + 2) * 3}"
```

Запустіть файл **string_eval.rb** і перевірте чи мали ви рацію.

> ## Коментарі
>
> Рядки, що починаються з символу решітки вважаються інтерпретатором Ruby як коментарі (тобто інтерпретатор просто їх ігнорує):
>
> ```ruby 
> # Це коментар
> ```

## Методи

У попередньому прикладі я коротко представив метод Ruby без жодних його пояснень та деталей синтаксису, яких вимагає цей метод. Зараз я виправлю свою помилку.

Ми називаємо це методом через те, що він забезпечує шлях (метод) для доступу до об'єкта. В термінології ООП, ви відправляєте повідомлення до об'єкта з проханням зробити щось. Уявімо, що у вас є об'єкт з іменем `ob` який має метод `saysomething`. Ось так ви б вивели повідомлення методу `saysomething`:

**`object.rb`**:

```ruby
ob.saysomething
```

Припустимо, що метод `saysomething` виглядає наступним чином:

```ruby
def saysometing
    puts("hello")
end
```

Результатом є те, що коли ви надішлете до `ob` повідомлення `saysomething` він відповідність методом `saysomething` та виведе “hello”.

Гаразд, ось це і є опис цих речей у стилі “чистого ООП”. У “не зовсім чистому” ООП це можна пояснити так: `saysomething` є чимось на зразок функції, яка зв’язана з об’єктом і може бути викликана з допомогою крапкового запису: `ob.saysomething`.

**`method.rb`**:

У Ruby метод описується з допомогою ключового слова `def` після якого слідує назва метода, яка має починатись з маленької літери, ось так:

```ruby 
def showstring
    puts( "Hello" )
end
```

Після назви методу, ви можете передати один або декілька аргументів, розділивши їх комою:

```ruby
def showname(a_name)
    puts("Hello #{a_name}")
end
```

```ruby
def return_name(a_firstName, a_secondName)
    return "Hello #{a_firstName} #{a_secondName}"
end
```

Як і сказано раніше, для зрозумілості, я писатиму у своєму коді дужки, проте ви можете упускати їх, якщо бажаєте.

**`mainob.rb`**:

> Якщо методи належать якимось об'єктам, як в попередньому прикладі з `ob` тоді якому об'єкту належать методи, які вільно стоять в коді? Як я вже казав раніше, Ruby автоматично створює об'єкт з ім'ям `main` коли ви запускаєте програму і саме цьому об'єкту належать методи, які вільно лежать в коді і не належать жодному об'єкту у коді вашої програми.

## Числа

Числа на стільки ж легко використовувати як і рядки. Припустимо ви хочете підрахувати ціну продажу, тобто загальну суму з врахування податків, чи зробити загальний підсумок.

Щоб визначити ціну продажу (subtotal) необхідно помножити вартість продукту на встановлені податкові норми (taxrate) та додати до отриманого додаткову вартість (витрати). Припустимо, що ціна продажу складає $100, а податок складає 17.5%, цей код порахує і виведе результат:

```ruby
subtotal = 100.00
taxrate = 0.175
tax = subtotal * taxrate
puts "Tax on $#{subtotal} is $#{tax}, so grand total is $#{subtotal+tax}"
```

Звісно, краще буде виконувати розрахунки на різних видах цін продажу, ніж на підрахунку одного і того ж самого виду знову і знову. Ось найпростіша версія розрахунку податків, яка нагадує користувачеві зазначити ціну продажу:

```ruby
taxrate = 0.175
print "Enter price (ex tax): "
s = gets
subtotal = s.to_f
tax = subtotal * taxrate
puts "Tax on $#{subtotal} is $#{tax}, so grand total is $#{subtotal+tax}"
```

Тут `.to_f` — це метод класу `String`. Він перетворює рядок в число з плаваючою комою. Для прикладу рядок `"s"` перетвориться в число `145.5`. Якщо рядок не може бути перетворений у число плаваючою комою  - інтерпретатор поверне нам об'єкт `0.0`. Наприклад, `"Hello world".to_f` поверне в якості результату `0.0`

## Перевірка умови: `if ... then`

Проблема з простим обчислювачем податку, код якого наведено вище, у тому що він може приймати від’ємні проміжні суми та видавати від’ємне значення податку — ситуація, яка навряд чи буде вигідна для уряду! Тому мені потрібно перевіряти наявність мінуса у чисел, і, якщо він присутній, встановлювати їм нульове значення. Ось оновлена версія мого коду:

**`tax_calculator.rb`**:

```ruby
taxrate = 0.175
print "Enter price (ex tax): "
s = gets
subtotal = s.to_f
if (subtotal < 0.0) then
    subtotal = 0.0
end
tax = subtotal * taxrate
puts "Tax on $#{subtotal} is $#{tax}, so grand total is $#{subtotal+tax}"
```

В Ruby умова `if` схожа на `if` умови в інших мовах програмування. Однак, зауважте, що дужки є необов’язковими, так само як і ключове слово `then`. Тим не менше, якщо б ви написали те саме без переходу на новий рядок після перевірки умови, тоді `then` має бути обов’язково.

```ruby
if (subtotal < 0.0) then subtotal = 0.0 end
```

Зауважте ключове слово `end`, яке вказує, що блок `if` є _обов’язковим_. Якщо ви забудете його, ваш код не запуститься.

> **Примітка перекладача**
> 
> Цю саму умови ви можете написати ось так:
>
> ```ruby
> subtotal = 0.0 if subtotal < 0.0
> ```
> 
> … або так:
>
> ```ruby
> subtotal = 0.0 unless (subtotal > 0.0) || (subtotal == 0)
> ```
