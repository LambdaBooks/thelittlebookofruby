#
Розділ перший

Якщо ви читаєте цю книгу, то мабуть маєте бажання програмувати на мові Ruby, і якщо ви схожі на мене – вам вже хочеться прочитати її. Що ж, не будемо витрачати час дарма.

Я припускаю, що у вас вже є встановлена мова Ruby, якщо ж ні - для початку вам потрібно встановити її і повернутися сюди.

Тепер, починаємо програмувати. Відкрийте ваш текстовий редактор, створіть файл **helloworld.rb** та запишіть в нього наступне:

```ruby
puts "Hello, World!"
```

Тепер запустіть вашу програму в терміналі командою:

```bash
$ ruby helloworld.rb
```

Якщо все добре - вам повинно вивести в термінал: `Hello, World!`

Це була найпростіша і найкоротша програма в історії програмування, тому ми одразу переходимо до отримання інформації від користувача...

Очевидний наступний крок - ми повинні "отримати" рядок. Ви могли вже здогадатися, що в Ruby такий метод називається `.gets`

> ### Об'єкти і Методи
>
> Ruby - повнісю об'єктно орієнтована мова програмування. Все: від цифри до рядка - є об'єктом. Кожен об'єкт має вбудовані методи, які можуть бути застосовані для виконання якихось операцій над ним. Для того щоб застосувати метод, ви повинні поставити крапку після об'єкта і написати ім'я методу. Для прикладу, тут я використаю метод `.upcase`  щоб вивести рядок "**hello world**" у верхньому регістрі:
>
> Створіть файл **uppercase.rb **
>
> ```ruby
> puts "hello world".upcase
> ```
>
> Деякі методи, такі як `puts` і `.gets`  доступні скрізь, і не потребують зв'язку з конкретним методом. Говорячи технічною мовою, ці методи забезпечуються модулем ядра Ruby і вони включені до кожного об'єкта в Ruby. Коли ви запускаєте Ruby додаток - автоматично створюється головний об'єкт, який надає доступ до методів Ядра..

Створимо програму **helloname.rb **

Програма **helloname.rb **повинна запитати в користувача його ім'я, припустимо, що це **"Fred" **тоді на моніторі повинно з'явитися привітання **"Hello Fred"**. Нижче зображений один з варіантів написання такої програми:

```ruby
print 'Enter your name:'
name = gets
puts "Hello #{name}"
```

Це все виглядає дуже просто, але водночас потрібно детальніше розглянути деякі нюанси.

По-перше, зверніть увагу, що я викорисав `print`, а не `puts` для запиту на введення імені. Це тому, що `puts` в кінці рядка ставить символ переносу на новий рядок, на відміну від `print`, який такого не робить. В даному випадку я хочу, щоб курсор залишався в тому ж рядку що і запит вводу тексту.

В наступному рядку я використовую `gets` для зчитування введеної кристувачем інформації, яке відбувається після натиснення клавіші Enter. Цей рядок призначений змінній **name**. Я попередньо не визначав цієї змінної і до того ж я не вказав її тип. В Ruby ви можете створювати змінні коли захочете і Ruby сама визначить їхній тип. Тут я присвоїв змінній **name **рядок і Ruby сама визначила, що тип змінної повинен бути string.

> Нотатка: Ruby чутлива до регістру. Тобто змінна `myvar` і `myVar` - дві різні змінні. Змінні, такі як `name`  у нашому прикладі - повинні починатися з малої літери.

До речі, в Ruby зазвичай дужки не є обов'язковими, ваш код без дужок так само буде працювати. Дужки допомагають уникати двозначності в коді і в деяких випадках інтерпритатор попередить вас, якщо ви їх пропустите. Деякі Ruby розробники полюбляють пропускати дужки щоразу, коли це можливо - я не поділяю їхньої думки. Тому в цій книзі ви будете бачити приклади коду саме з дужками. \(А так як перекладач цієї книги терпіти не може дужки - наврядчи ви їх тут побачите.\)

## Рядки та Інтерполяція

Останній рядок файлу **helloname.rb** досить цікавий:

`puts "Hello #{name}"`

Тут змінна `name` вбудовує себе в рядок. Це відбувається шляхом розміщення змінної між двома фігурними дужками, перед якими стоїть символ решітки `#{}`. Такий тип вбудованого обчислення працює тільки в рядках з подвійними лапками.

В подвійних лапках ви можете не тільки вбудовувати змінні, а також маєте можливість вставити такі символи як `"\n"` - символ переносу рядка та інші.

Ви навіть можете вставляти програмний код або математичні вирази. Уявімо, що у вас є метод `showname` який повертає рядок **"Fred"**. Наступний рядок буде містити інтерполяцію і викличе метод `showname`. У результаті буде відображатися рядок **"Hello Fred"**:

> Для цього створимо інший файл: **string\_eval.rb**

```ruby
puts "Hello #{showname}"
```

Уважно подивіться і подумайте, що може вивести наступний рядок:

```ruby
puts "\n #{(1 + 2) * 3}"
```

Запустіть файл **string\_eval.rb** і перевірте чи мали ви рацію.

> ### Коментарі
>
> Рядки, що починаються з символу решітки - розглядаються інтерпритатором Ruby як коментарі \(Тобто інтерпритатор просто їх ігнорує\):
>
> `#Це коментар`

## Методи

У попередньому прикладі я коротко представив метод Ruby без жодних його пояснень та деталей синтаксису, яких вимагає цей метод. Зараз я виправлю свою помилку.

Ми називаємо це методом через те що він забезпечує шлях \(метод\) для доступу до об'єкта. В ООП термінології ви відправляєте повідомлення до об'єкта з проханням зробити щось. Уявімо, що у вас є об'єкт з іменем `ob` який має метод `saysomething`. Ось так ви б вивели повідомлення методу `saysomething`:

> Файл **object.rb**

```
ob.saysomething
```

Припустимо, що метод `saysomething` виглядає наступним чином:

```ruby
def saysometing
puts "hello"
end
```

Після назви методу, ви можете предати один або декілька аргументів, розділишви їх комою:

```ruby
def saysometing a_name
puts "hello #{a_name}"
end
```

```ruby
def return_name a_firstName, a_secondName
return "Hello #{a_firstName} #{a_secondName}"
end
```

> Якщо методи належать якимось об'єктам, як в попередньому прикладі з `ob` тоді якому об'єкту належать методи, які вільно стоять в коді ? Як я вже казав раніше, Ruby автоматично створює об'єкт з ім'ям `main` коли ви запускаєте програму і саме цьому об'єкте належать методи, які вільно лежать в коді і не належать жодному об'єкту у коді вашої програми.

## Числа

Числа на стільки ж легко використовувати як і рядки. For example, let’s suppose you want to calculate the selling price or ‘grand total’ of some item based on its ex-tax value or ‘subtotal’.

To do this you would need to multiply the subtotal by the applicable tax rate and add the result to the value of the subtotal. Assuming the subtotal to be $100 and the tax rate to be 17.5%, цей Ruby код порахує і виведе результат:

```ruby
subtotal = 100.00
taxrate = 0.175
tax = subtotal * taxrate
puts "Tax on $#{subtotal} is $#{tax}, so grand total is $#{subtotal+tax}"
```

Obviously, it would be more useful if it could perform calculations on a variety of subtotals rather than calculating the same value time after time! Here is a simple version of a Tax Calculator that prompts the user to enter a subtotal:

```
taxrate = 0.175
print "Enter price (ex tax): "
s = gets
subtotal = s.to_f
tax = subtotal * taxrate
puts "Tax on $#{subtotal} is $#{tax}, so grand total is $#{subtotal+tax}"
```

Тут `.to_f` це метод класу **String**. Він перетворює об'єкт типу **String** в число з рухомою комою. Для прикладу рядок **"145.5"** перетвориться в число **145.5**. Якщо рядок не може бути перетворений до типу **Float** - інтерпритатор поверне нам об'єкт **0.0**, який належить класу **Float**. Наприклад:

```ruby
"Hello world".to_f
```

Поверне нам в якості результату **0.0**.

## Перевірка умови, if ... unless

> Файл **tax\_calculator.rb**

Проблема з простим обчислювачем податку, код якого наведено вище, у тому що він може приймати від’ємні проміжні суми та видавати від’ємне значення податку — ситуація, яка навряд чи буде вигідна для уряду! Тому мені потрібно перевіряти наявність мінуса у чисел, і, якщо він присутній, встановлювати їм нульове значення. Ось оновлена версія мого коду:

```ruby
taxrate = 0.175
print "Enter price (ex tax): "
s = gets
subtotal = s.to_f
if subtotal < 0.0
subtotal = 0.0
end
tax = subtotal * taxrate
puts "Tax on $#{subtotal} is $#{tax}, so grand total is $#{subtotal+tax}"
```

В Ruby умова if схожа на if умови в інших мовах програмування. Також ви можете записати наступну умову в один рядок, за допомогою синтаксичного цукру Ruby:

```ruby
subtotal = 0.0 if subtotal < 0.0
```

Або:

```ruby
subtotal = 0.0 unless (subtotal > 0.0) || (subtotal == 0)
```




