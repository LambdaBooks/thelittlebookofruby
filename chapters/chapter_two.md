##Розділ другий
> Визначення класів та створення об'єктів

Досі ми використовували "страндартні" об'єкти рубі, такі як цифри і рядки. Тепер давайте подивимося, як створювати наші власні, нові типи об'єктів. Як і в будьшості об'єктно орієнтованих мов програмування, в Ruby об'єкт визначається класом. Клас подібний плану, з якого все будується. Це приклад дуже простого класу:

```ruby
class MyClass

end
```

А тут я створюю об'єкт нашого простого класу:

```ruby
object = MyClass.new
```

Я небагато можу зробити з нашим об'єктом хоча б тому, що нічого не запрограмував в класі **MyClass** з якого він був створений.

> Файл **object\_class.rb**
>
> Насправді, якщо ви створите порожній клас як MyClass, об'єкти створені від нього - не будуть зовсім марними. Усі класи в  Ruby автоматично успадковують всластивості класу Object. То ж наш об'єкт може використовувати методи класу Object, наприклад такі, як `.class`  \(Виводить назву класу, якому належить наш клас\):
>
> ```
> puts ob.class #=> Покаже нам: “MyClass”
> ```

Щоб зробити MyClass трохи кориснішим - додамо в нього один або декілька методів. У цьому прикладі, що був коротко заганий у попередньому розділі, я додав метод, який називається **saysomething**:

```ruby
class MyClass
  def saysomething
    puts("Hello")
  end
end
```

Тепер, якщо я створю об'єкт класу MyClass, я зможу викликати метод цього об'єкта saysomething і вивести слово "**Hello**":

```ruby
ob = MyClass.new
ob.saysomething
```

### Екземпляри і змінні екземплярів класів

Створимо кілька корисних об'єктів. Дім не повинен бути без собаки, тож давайте створимо склас Dog:

```ruby
class Dog
  def set_name(aName)
    @myname = aName
  end
end
```

Зверніть увагу, що визначення класу починається з ключового слова **class** \(в нижньому регістрі\), а після нього йде назва класу, що повинна починатися з великої літери. Мій клас **Dog** містить один метод **set\_name**. Він приймає вхідний аргумент **aName**. Значення **aName** в свою чергу присвоюється інстанс змінній **@myname** в середині методу **set\_name**.

> Змінні, що починаються з символу @ \(комерційне "at"\) є "інтанс змінними". Це означає, що вони належать індивідуальним об'єктам класу або "екземплярам" класу.

Я можу створити екземпляр класу **Dog**, тобто "об'єкт собака", викликавши метод **new**. Тут я створюю два об'єкти класу Dog тобто "дві собаки" \(пам'ятайте, що імена класів починаються з великої літери; Імена об'єктів складаються з літер нижнього регістру\):

```ruby
mydog = Dog.new
yourdog = Dog.new
```

Зараз ці дві собаки не мають імен. Тож наступну річ, яку я маю зробити аби задати їм імена - це викликати метод `set_name`:

```ruby
mydog.set_name('Fido')
yourdog.set_name('Bonzo')
```

Задавши імена собакам, мені потрібно мати спосіб дізнати їх пізніше. У кожної собаки повинно бути власне ім'я, тому давайте створимо метод `get_name`:

```ruby
def get_name
  return @myname
end

```

Слово `return` тут є необов'язковим. В Ruby методи завжди повертають значення останнього обчисленого виразу. Але для більшої ясності \(і уникнення несподіваних результатів від методів складніших за цей\) - ми все ж використовуватимемо слово `return`.

Давайте задамо поведінку нашій собаці, наприклад навчити її відгукуватися. Нижче визначений закінчений клас `Dog`:

> Файл dogs_and_cats.rb

```ruby
class Dog   
  def set_name( aName )
    @myname = aName
  end
  def get_name
    return @myname
  end
  def talk
    return 'woof!'
  end
end
```

Тепер ми можемо створити собаку, задати її ім'я, дізнатися її ім'я і попросити її відгукнутися:

```ruby
mydog = Dog.new
mydog.set_name('Fido')

puts mydog.get_name
puts mydog.talk
```

Для різноманітності та практики - можете створити файл **dogs_and_cats.rb** і задати в ньому поведінку не тільки собаці, а й коту, створивши відповідно новий клас `Cat`.

###Конструктор - new і initialize

>Файл **treasure.rb**

Зараз розглянемо ще один приклад класу. Ми створимо пригодницьку гру з двома класами: `Thing` і `Treasure`. Клас `Thing` дуже схожий на клас `Dog` з нашої попередньої програми (Ну крім того, що він не вміє гавкати).

Проте в класа `Treasure` теж є кілька цікавих особливостей. По-перше в нього немає таких методів як `get_name` і `set_name`. Замість цього в ньому об'явлений метод initiaize, який приймає два аргументи, а їх значення присвоюються інстанс змінним `@name` і `@description`:

```ruby
def initialize( aName, aDescription )
  @name = aName
  @description = aDescription
end
```


 